# Черкаський національний університет ім. Б. Хмельницького
## Лабораторні та практичні роботи ООП C#
### Л1. ОБРОБКА МАСИВІВ У C#(Lab_1)
Варіант 5
1. В матриці C кількість стовпчиків у кожному рядку є випадковим натуральним
числом з інтервалу [a; b], але загальна кількість елементів є квадратом
натурального числа. Переписати всі елементи з матриці C в одновимірний масив
F, відсортувати його за зростанням, після чого переписати його елементи у
квадратну матрицю Q по рядках.
2. Створити клас TTriangle для подання трикутника. Поля (protected) повинні містити дані про довжини сторін (для кожної з трьох сторін своє поле). Потрібно реалізувати:
* конструктор, який заповнює всі три довжини (перевіряючи можливість існування такого трикутника);
* отримання (get) довжини сторони (три окремі методи, для кожної сторони свій);
* задання (set) довжини сторони (три окремі методи, для кожної сторони свій; перевіряти можливість існування такого трикутника, де ця одна сторона змінена, а решта дві лишаються, які були);
* отримання периметру трикутника
* отримання площі трикутника (через формулу Герона)

### Л2. Поліморфізм та наслідування(Lab_3)
Варіант 6<br>
Реалізувати клас, що представляє трикутник (трикутник задається координатами вершин) і містить опис індексатора для доступу до сторін трикутника( a – перша
сторона, b – друга сторона, c – третя сторона).
Передбачити методи введення/виведення, знаходження периметру та площі.<br>
Варіант 6<br>
1. Клас “коло” – TCircle<br>
- Поля:<br>
	- для зберігання радіуса;<br>
- Методи:<br>
	- конструктор без параметрів, конструктор з параметрами, конструктор копіювання;
	- override public string ToString();
	- введення/виведення даних;
	- визначення площі круга (обмеженого колом), площі сектора (кут є параметром);
	- визначення довжини кола;
	- порівняння з іншим колом;
	- перевантаження операторів + (додавання радіусів), – (віднімання радіусів; при від’ємному результаті брати за модулем), (множення радіуса на число; забезпечити, щоб домноження могло відбуватися хоч як «число коло», хоч як «коло число»).<br>
2. Створити клас-нащадок TCylinder (циліндр) на основі класу TCircle. Додати поле висоти циліндру, метод знаходження об’єму циліндра та перевизначити відповідні методи.<br>
3. Створити програму-клієнт для тестування.<br>


### Л3. Тема(Lab_2)
Реалізуйте клас MyMatrix, який зберігає прямокутну числову матрицю і вміє виконувати дії
додавання матриць та множення матриць.
Матриця повинна містити єдине приватне поле — масив із власне елементами матриці (типу
double[,]) .<br>
Слід реалізувати такі конструктори, оператори, властивості та методи (усі публічні, якщо
тільки не вказано іншого):
- Конструктори:<br> 
	- **копіюючий з іншого примірника цього самого класу MyMatrix;**
	- **з двовимірного масиву типу double[,];**
	- **з «зубчастого» масиву double-ів, якщо він фактично прямокутний;**
	- **з масиву рядків, якщо фактично ці рядки містять записані через пробіли та/або
	числа, а кількість цих чисел однакова.**
	- **з рядка, що містить як пробіли та/або табуляції (їх трактувати як роздільники
	чисел у одному рядку матриці), так і символи переведення рядка (їх трактувати
	як роздільники рядків) — якщо фактичні дані того рядка утворюють прямокутну
	числову матрицю; зокрема, щоб цим конструктором можна було створити
	матрицю з рядка, раніше сформованого методом ToString (див. далі))**<br>

* **operator + додавання двох матриць (якщо вони мають однаковий розмір)**
* **operator * множення двох матриць (якщо кількість стовпчиків першої дорівнює
кількості рядків другої)**
* **Властивості (Properties) Height та Width, що дозволяють взнати (але не дозволяють
змінити) «висоту» (кількість рядків) та «ширину» (кількість стовпчиків)**
* **Java-style getter-и (без setter-ів) кількості рядків getHeight() та кількості
стовпчиків getWidth()**
* **Індексатори, що дозволяють публічно доступатися до будь-якого окремого елемента
матриці (як взнавати його значення, так і змінювати)**
* **Java-style getter та setter для окремого елемента (getter має два параметри — номер
рядка і номер стовпчика, setter має три параметра — номер рядка, номер стовпчика, і
значення, яке записати у той рядок і стовпчик)**
* **Метод override public String ToString(), перевантажений так, щоб
формував (табуляціями та переведеннями рядка) зручне для сприйняття людиною
прямокутне подання числової матриці; це повинен бути метод саме з вищенаведеним
заголовком, бо саме так вдається забезпечити, щоб примірники цього класу можна
було виводити просто через Console.WriteLine(A) (де A – примірник цього
самого класу MyMatrix)**
* **Метод (не статичний; private або protected) GetTransponedArray(), що повертає
новостворений масив double[,] (не MyMatrix, а просто масив), у якому вміст
елементів транспонований відносно тієї матриці, для якої він викликався**
* **Метод (не статичний) MyMatrix GetTransponedCopy(), який би створював
новий примірник MyMatrix, у якому вміст матриці транспонований відносно тієї,
для якої він викликався; технічну роботу по власне транспонуванню не повторювати,
а використати результат GetTransponedArray()**
* **Метод (не статичний) void TransponeMe(), який би замінював матрицю, для якої
викликається, на транспоновану (теж використати GetTransponedArray(), але
щоб результат змінився сам this-примірник MyMatrix).**
<br>
В усіх випадках неправильних даних (намагання створити матрицю з фактично
не прямокутного «зубчастого» масиву; намагання створити матрицю з масиву рядків, який
фактично містить взагалі не числа; намагання доступитися до неіснуючого елемента;
намагання додати матриці різного розміру, тощо) як базовий (стандартний) спосіб
пропонується, щоб виконання програми просто аварійно завершувалося. Рятування ситуації
шляхом коректної роботи з exception-ами – правильний підхід, вітається (хоч і
не вимагається). Намагання нівелювати ці помилки будь-якими іншими засобами –
неправильний підхід, категорично забороняється.


### Л4. Виключні ситуації(exceptions)
1. Напишіть програму, яка повніша прочитати з кожного з файлів  
10.txt, ll.txt. 12.txt. 13.txt, 14.txt, 15.txt, 16.txt, 17.txt, 18.txt. 19.txt, 
20.txt. 21.txt, 22.txt, 23.txt, 24.txt. 25.txt, 26.txt. 27.txt, 28.txt. 29.txt  
по два цілі числа (у звичайному десятковому записі, перше у першому рядку (при нумерації з 1). друге у другому),
- обчислити добутки цих чисел, 
- і суму всіх цих добутків.  

Можливі які завгодно порушення: деяких з цих файлів може не бути: у деяких з файлів може бути неадекватна інформація (замість цілих чисел — дробові, або взагалі не числа), і так далі.  
Крім того, добутки потрібно рахувати в типі int (32-бітовому), і враховувати тільки ті з них. які поміщаються у цьому типі.  
Програма повинна видати у консоль знайдене середнє арифметичне (лише тих добутків, які вдалося обчислити), та створити/перезаписати файли:
- no_file.txt —перелік відсутніх файлів
- bad_data.txt —перелік файлів, з перших двох рядків яких яких неможливо прочитати два цілі числа у звичайному десятковому записі. 
Мова йде саме про перші два рядки: якщо саме вони не містять двох цілих чисел або містять щось зайве — вважати, що файл поганий, не намагаючись знайти їх десь далі: якщо після двох цілих чисел є ще щось — байдуже, воно може бути чим завгодно.  
- overflow.txt —перелік файлів, з яких можливо прочитати два цілі числа, які поміщаються у 32-бітовий тип int, але добуток цих прочитаних двох чисел не поміщається у 32-бітовий тип int.  

У випадку, якщо хоча б один з файлів no_file.txt. bad_data.txt. overflow.txt створити оповити не виходить — програма повинна негайно обірватися, видавши у консоль (свос!) повідомлення про цей факт. Мається на увазі першопочаткове створення/оновлення: малоймовірну ситуацію, коли файл успішно створили, а потім по дорозі раптом стало неможливо в нього писати, дозволяється не обробляти.
- При всьому цьому, у програмі категорично заборонено мати хоча б один if: 
- усі перевірки мають відбуватися засобами exception-ів. 
- Цикл теж повинен бути один —той, який перебирає файли:
10.txt. ll.txt. 12.txt. 13.txt, 14.txt. 15.txt, 16.txt. 17.txt, 18.txt. 19.txt.
20.txt, 21.txt. 22.txt. 23.txt, 24.txt. 25.txt, 26.txt. 27.txt. 28.txt, 29.txt.  

Тут може виникнути питання — «а як таке взагалі відлагодити. якщо я завжди можу писати у текстові файли?».  
Взагалі-то ситуацій, коли неможливо створити файл, не так уже и мало, а один з найпростіших способів створити таку ситуацію, не зв'язуючись ні з мережею, ні з правами доступу файлової системи — перед запуском програми створити *папку* no_file.txt. або bad_data.txt. або overflou.txt.

2. Напишіть програму, яка буде перебирати усі файли поточної папки і намагатися кожен з них розглянути як графічний (картинку) і виконати дзеркальне відбивання (по вертикалі). 
	- Список усіх файлів папки можна отримати як Directory. GetFi les (. . . ), де замість . . . можна або узяти поточну папку (Directory.GetCurrentDirect()), або дописати, щоб конкретна папка вибиралася користувачем інтерактивно.
	- Після цього конкретні файли можна перебрати просто як foreach (String fileName in . . . ). де — результат того самого GetFiles.
Для роботи з графічними файлами пропонується використати System.Drawing.Bitmap. Цей клас вміє обробляти не лише формат BMP. а й деякі інші. 
Якщо і виявиться, що не всі формати (па деякі картинки малопоширеиих форматів казатиме, що то не картинки) — вважайте це неприємним, але не істотним.  

Решту деталей знайдіть самостійно, користуючись MSDN та іншими інтернет-ресурсами.
- Для кожного файла, який вдається успішно прочитати як картинку, треба створити новий.  
- Незалежно від формату початкового файла, результат писати у форматі gif. 
- Назвати новий файли треба так: узяти старе ім'я (відкинувши розширення, якщо воно було), дописати до імені “-mirrored" та замінити розширення на “.gif'.  
- Якщо файл не вдається прочитати як картинку (взнавати це слід за тим. чи виник exception у процесі читання картинки з файлу), поведінка повинна залежати від того, чи є його розширення одним із розширень графічних форматів: якщо не є — просто продовжити роботу, перейшовши до наступного файлу, якщо є — видати (через MessageBox. Show(. . .)) власне повідомлення про те, що файл не містить картинки, хоча, судячи з розширення, повинен.  
(Один зі способів перевірити розширення — перевірити відповідність власноруч написаному регулярному виразу. Наприклад, один раз перед циклом перебору файлів написати Regex regexExtForImage = new Regex("~ ((bmp) I (gif ) I (tif f ?) I (jpe?g) I (png)) $", RegexOptions . IgnoreCase);
а уциклі перевіряти if(reg exExtForlmage.IsMatch(Path.GetExtension(fileName)))).

Насамкінець, воно на перший погляд здається складним (бо новим), а насправді все досить просто та вельми коротко: єдиний метод, порядка ЗО рядків, з яких приблизно половина містять або саму лише фігурну дужку або щось дуже просте.

Оскільки програма повинна обробляти картинки, але не зобов'язана відображати їх, теоретично це може бути хоч програма з графічним інтерфейсом, хоч консольна програма (особливо якщо дозволити виводити повідомлення хоч MessageBox-ом.хоч у консоль).  
Практично при цьому виникає таке ускладенння: 
- у програмі з графічним інтерфейсом для підключення класів Image та Bitmap достатньо, щоб на початку тексту програми було написано using System.Drawing;, а для консольної програми, крім цього, треба іце вручну підключити бінарний файл відповідної бібліотеки.  

Наприклад, так: у Solution Explorer-і вибрати References, натиснути правою кнопкою миші, вибрати «Add Reference...», знайти потрібну бібліотеку (System. Dr awing для Image та Bitmap. System. Windows .Forms для MessageBox. тощо) у списку «Framework», вибрати (ліворуч повинна з'явитися галочка (checkbox)), підтвердити цей вибір через «OK».

### Л5. Тема


### Л6. Тема
Розмістіть на формі поле введення (Textbox), і дві кнопки (Button) з написами:
«блокувати», «розблоковувати». Створіть обробники події натиснення на кнопки, які
робитимуть активним або неактивним поле введення. Створіть обробник події натиснення
кнопки мишки на формі (Click), який встановлюватиме колір форми і робитиме
невидимими всі елементи.

### Л7. Тема

### Л8. Тема

### Л9. Тема

### Л10. Тема

### Л11. Тема

### Л12. Тема
